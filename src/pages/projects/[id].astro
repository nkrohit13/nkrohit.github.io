---
import { type CollectionEntry, getCollection, render } from 'astro:content';
import FormattedDate from '../../components/FormattedDate.astro';
import ProjectPreview from '../../components/ProjectPreview.astro';
import BaseLayout from '../../layouts/BaseLayout.astro';
import { sortItemsByDateDesc } from '../../utils/data-utils';

export async function getStaticPaths() {
    const projects = (await getCollection('projects')).sort(sortItemsByDateDesc);
    const projectCount = projects.length;
    return projects.map((project, index) => ({
        params: { id: project.id },
        props: {
            project,
            prevProject: index + 1 !== projectCount ? projects[index + 1] : null,
            nextProject: index !== 0 ? projects[index - 1] : null
        }
    }));
}

type Props = {
    project: CollectionEntry<'projects'>;
    prevProject: CollectionEntry<'projects'>;
    nextProject: CollectionEntry<'projects'>;
};

const { project, prevProject, nextProject } = Astro.props;
const { title, description, seo, contactTitle, contactText } = project.data;
const { Content, headings } = await render(project);

// Prepare items to show in the "View Next" grid. If only one adjacent project
// exists (prev or next), pick a fallback project from the collection so the
// grid always shows two items.
let viewItems = [] as Array<CollectionEntry<'projects'>>;
if (nextProject) viewItems.push(nextProject);
if (prevProject) viewItems.push(prevProject);
if (viewItems.length < 2) {
    const allProjects = (await getCollection('projects')).sort(sortItemsByDateDesc);
    const candidate = allProjects.find((p) => p.id !== project.id && !viewItems.some((v) => v.id === p.id));
    if (candidate) viewItems.push(candidate);
}
---

<BaseLayout
    title={seo?.title ?? title}
    description={seo?.description ?? description}
    image={seo?.image}
    pageType="article"
    showHeader={false}
    contactTitle={contactTitle}
    contactText={contactText}
>
    <article class="mb-16 sm:mb-24">
        <nav id="toc-rail" class="toc-rail" aria-label="Table of contents">
            {
                headings && headings.length > 0 && (
                    <ul class="toc-list">
                        {headings
                            .filter((h) => h.depth <= 3)
                            .map((h) => (
                                <li class={`toc-h${h.depth}`}>
                                    <a href={`#${h.slug}`} class="text-sm text-gray-300 hover:underline">
                                        {h.text}
                                    </a>
                                </li>
                            ))}
                    </ul>
                )
            }
        </nav>
        <header class="mb-12 border-b border-gray-300/10 pb-8">
            <h1 class="project-detail-title">
                {title}
            </h1>
            <div class="mt-4 flex flex-wrap items-center gap-4 text-sm text-gray-400">
                <FormattedDate date={new Date(project.data.publishDate)} />
            </div>
        </header>
        <div class="max-w-none prose sm:prose-lg">
            <Content />
        </div>
        {
            (prevProject || nextProject) && (
                <div class="my-16 sm:my-24">
                    <hr class="border-t border-gray-300/10 mb-4" />
                    <h2 class="mt-4 mb-8 text-xl font-sans sm:mb-12 sm:text-2xl">View Next</h2>
                    <div class="view-next grid grid-cols-1 md:grid-cols-2 gap-8">
                        {viewItems.map((p) => (
                            <ProjectPreview project={p} className="" headingLevel="h3" />
                        ))}
                    </div>
                </div>
            )
        }
    </article>
    <script>
        // Simple TOC positioning: align with header bottom, then stick at top
        function updateTOCPosition() {
            const toc = document.getElementById('toc-rail');
            const header = document.querySelector('article header');
            if (!toc || !header || window.innerWidth < 1024) return;

            const headerRect = header.getBoundingClientRect();
            const stickyTop = 80; // Distance from top when stuck

            if (headerRect.bottom > stickyTop) {
                // Header is visible, align TOC with header bottom
                const absoluteTop = window.scrollY + headerRect.bottom;
                toc.style.position = 'absolute';
                toc.style.top = absoluteTop + 8 + 'px';
            } else {
                // Header scrolled past, stick TOC at top
                toc.style.position = 'fixed';
                toc.style.top = stickyTop + 'px';
            }
        }

        // Run on load and scroll
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', updateTOCPosition);
        } else {
            updateTOCPosition();
        }
        window.addEventListener('scroll', updateTOCPosition, { passive: true });
        window.addEventListener('resize', updateTOCPosition);
    </script>
</BaseLayout>
